# 1장 테스트 목적과 장애물

테스트의 중요성은 몸으로 느껴야 한다.
협업 할 때, 리뷰어를 배려하는 수단이 될 수도 있고, 서비스 품질 및 코드 품질을 위한 수단이 될 수 있다.
테스트 코드는 단순히 “중요하니까 해야해”가 아니라 필요한 곳에서 수단으로서 사용되어야 한다.

장기적으로 봤을 때, 팀에서 소모되는 시간은 줄어든다.
팀원들을 설득하려면 “참고할 수 있는 테스트 코드”가 있어야 한다.

## **생각정리**

이번에 잘 공부해서 테스트 코드를 먼저 작성하고 팀 에게 공유해보자!

# 2장 테스트 방법과 테스트 전략

테스트는 목적에 따라서 단위 테스트, 통합 테스트, E2E 테스트로 나눈다.

소프트웨어 테스트 분야에서 알려진 테스트는 아래와 같다.

1. 기능 테스트
   1. 유닛, 통합 테스트 등
2. 비기능 테스트
   1. 성능 부하, 보안 테스트 등
3. 화이트박스 테스트
   1. 직접 테스트
4. 회귀 테스트
   1. 새로운 기능 추가/수정 후에도 잘 동작하는지 확인 목적

Typescript에서는 정적 분석도구(eslint 등)도 버그를 줄여주는 훌륭한 정적 코드 분석 도구중 하나다.

테스트 전략 모델은 여러가지가 있는데,
그 중 “테스트 피라미드” 형태는 “리소스(비용)” “효율(가성비)”로 그려진다.

1. E2E 테스트
2. 통합 테스트
3. 단위 테스트

밑으로 갈 수록 “효율”은 커지고 “리소스”는 낮아진다.
반대로 위로 올라갈수록 “리소스”는 커지고 “효율”은 낮아진다.

단 위로 올라갈수록 실제 사용자가 사용하는 시나리로와의 유사성은 높아진다.

“테스팅 트로피” 형태는 4가지로 구성된다.

1. E2E 테스트
2. 통합 테스트
3. 단위 테스트
4. 정적 분석

이 모델은 통합 테스트의 비율이 제일 높은데, FE 특성상 UI 코드가 많고, 상호작용 테스트가 실제 사용자에게 전달되는 품질과 직결되기에
해당 테스트의 비율이 가장 높아야 한다고 말한다.

## **생각정리**

통합 테스트를 많이 작성하면 좋지만, 빠르게 개발해야 하는 환경에서 통합 테스트를 작성하기는 쉽지 않다.
데이터에 의존성이 생기고, API나 기타 외부 요인에 의존성이 생기는 시점부터 테스트의 난이도는 올라가기 때문이다.
어떻게 하면 빠르게 테스트를 잘 짤 수 있을지 구조화를 생각해보는 것도 필요할 것 같다.

# 3장. 처음 시작하는 단위 테스트

1. describe는 중첩이 가능하기에 논리별로 묶어서 테스트를 작성한다.
   1. i.g) 사칙연산 → add, 사칙연산 → sub 논리로 묶어서 작성
2. 테스트 명은 행동 중심으로 설계한다.
   1. 나쁜 예: 10 + 20 = 30 이다.
   2. 좋은 예: 반환 값은 첫번째 상수와 두번째 상수를 더한 값이다.
3. throw 가 필요한 테스트의 경우 arrow 함수로 감싸준다.
4. Error instance를 지정해서 테스트할 수 있다.
5. callback, resolves, async/await 통해 비동기 함수 테스트 가능.
   1. promise reject시에도 cache로 테스트 가능.
6. expect.assertions를 통해 예외처리를 테스트할 때, 단언문의 호출 갯수를 체크해서 실수 방지 가능.

외에 3장은 사용법에 대한 이야기들이라 따로 짚어야할 부분은 없어보인다. 사용하면서 익혀봐야 할 것들이 많다.

## **생각정리**

테스트 설명문을 작성할때는 꼭 행동 중심 워딩으로 작성하자.
테스트 코드는 유지보수를 위해서 작성하는 수고스러움인데, 나중에 다시 봤을 때 의사 전달이 제대로 되지 않는다면 테스트를 작성하는 의미가 흐려진다.
수식 또는 요약이 아닌 명확한 행동으로 작성하자.

# 4장. Mock 객체

용어 설명

일반적으로 “xunit 테스트 패턴" 책의 용어를 인용한다.

1. stub
   1. 대역
      1. 의존중인 컴포넌트 대역
      2. 정해진 값 반환 용도
      3. 테스트 대상에 할당하는 입력값
   2. 행동의 주체라고 보면 편할 듯 하다.
2. spy
   1. 기록하는 용도
      1. 함수, 메서드 호출 기록
      2. 호출 횟수 및 실행 시 사용한 인수 기록
      3. 테스트 대상의 출력 확인
   2. 테스트 대상 외부의 출력을 검증할 때 사용함.

- jest.spyOn(object, methodName)
  - type safe한 function mocking함수
- jest.setSystemTime(Date)
  - 시스템 날짜 mocking 함수

## 생각정리

아래처럼 미구현 단계인 함수를 먼저 mocking해서 테스트 하는 경우,
TDD 방식으로 테스트를 먼저 작성할 때 설계에 큰 도움이 될 수 있는 방식이다.

```tsx
jest.mock("./greet", () => ({
  sayGoodBye: (name: string) => `Good bye, ${name}.`,
}));
```

mocking을 상세하게 할 줄 알아야
테스트를 내가 원하는 부분만 맞춰서 할 수 있을 것 같다.
아직까지 책만보고 뭔가를 익히기에는 어렵네요.
감을 익히기 위해서 [cyber-dojo](https://cyber-dojo.org/)나 테스트 코드 작성을 연습할 수 있는 간단한 프로젝트를 같이 진행해보는것도 좋을 것 같아요.
저는 연습삼아 최근에 다시 만든 블로그에 테스트를 조금 끼워넣어 보려고 합니다.

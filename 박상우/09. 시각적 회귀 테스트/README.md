## 🟢 시각적 회귀 테스트의 필요성

### 💡 스타일 변경 검증의 어려움

스타일 코드는 야앙한 요소에서 영향을 받기 때문에 코드만으로 예측하는 것은 어렵다. 육안으로 요소의 스타일이 변하는 것을 확인하는 것이 좋지만 모든 페이지를 육안으로 확인하는 것은 한계가 있다.

스타일 코드를 수정했을 때에도 스타일 코드가 적용되는 범위가 모두 달라 의도하지 않은 변경이 일어날 수도 있다.

특히 컴포넌트 블록들을 조립하는 방식으로 개발하는 컴포넌트 기반 개발은 로직 작성과 관리에 이점이 있지만 컴포넌트 사이 공통된 CSS에 대한 수정 여파가 크다는 단점이 생긴다.

 <br />

### 💡 시각적 회귀 테스트를 스냅숏 테스트로 대체할 수 있을까

클래스 속성으로 인해 스타일이 변경되는 것은 알 수 있지만, 전역에 정의된 스타일의 영향은 알기 어렵다.

→ 스냅숏 테스트의 경우 HTML 출력 결과만 가지고 비교하기 때문에 모든 시각적 회귀 테스트를 대체하지는 못한다.

<br />

### 💡 시각적 회귀 테스트의 선택지

실제 브라우저에 랜더링된 화면을 특정 시점에 캡처하고 그 이미지들을 픽셀 단위로 비교하는 것을 시각적 회귀 테스트라고 말한다.

E2E 테스트 프레임워크에서 지원하는 헤드리스 브라우저에서 테스트가 수행되며, 화면이 이동하면 화면을 캡처한다.

#### 1. 페이지 단위로 테스트하기

이동한 화면에 대해서 캡처하며, 모든 페이지를 캡처하여 스타일 변경 전후를 파악할 수 있다.

하지만 페이지 상단에서 차이가 발생하면 그 위치를 기준으로 하단 영역이 모두 변경된 부분으로 인식하기 때문에 자세한 차이점을 파악하기 어렵다.

#### 2. 컴포넌트 단위로 테스트하기

세세한 검출을 위해서 컴포넌트 단위의 시각적 회귀 테스트가 필요하다. Storybook의 Story로 세분화하면 개별 컴포넌트 단위로 시각적 회귀 테스트에서 활용할 수 있다.

<br />

## 🟢 reg-cli로 이미지 비교하기

`/actual` , `/expected` 디렉토리에 동일한 이름의 이미지 파일을 넣고 터미널에서 아래와 같이 실행시키면, -R 옵션 하위의 지정된 HTML파일로 결과를 확인할 수 있다.

```bash
npx reg-cli actual expected dff -R index.html
```

두 이미지의 차이점을 확인할 때는 해당 페이지로 접속하여 페이지 하단 버튼들을 통해서 전/후 결과를 비교 가능하다.

<img width="539" alt="스크린샷 2025-03-09 오후 4 14 22" src="https://github.com/user-attachments/assets/95963efe-333c-4ecc-aa35-2d097192313d" />
  
  
<br />
<br />

## 🟢 스토리 캡 도입

### 💡 스토리캡 설정

설치

```bash
npm install storycap --save-dev
```

설정

```bash
# .storybook/preview.js
import { withScreenshot } from 'storycap';

export const decorators = [ withScreenshot ];

# .storybook/main.js
module.exports = {
  addons: [
    ...
    "storycap",
    ...
  ]
}
```
<br />

### 💡 스토리캡 실행

```bash
{
  ...
  "scripts": {
    ...
    "storybook:build": "storybook build",
    "storycap": "storycap --serverCmd \"npx http-server storybook-static -a localhost -p 6006\" http://localhost:6006",
    ...
  }
  ...
}
```

`npm run storybook:build`를 통해 스토리북을 빌드한 후에 `npm run storycap` 을 실행하여 빌드된 스토리북을 정적 페이지로 실행해 모든 스토리를 캡처할 수 있다.

이후 임의로 css 코드를 수행한 후, 위 과정을 반복하면 reg-cli를 통해 두 컴포넌트간 차이를 확인할 수 있다.

<br />

## 🟢 reg-suit 도입하기

### 💡 reg-suit 도입하기

외부 스토리지 + github actions + reg-suit을 활용해서 자동으로 시각적 회귀 테스트 리포트를 받을 수 있다. 흐름은 아래와 같다.

<img width="692" alt="image" src="https://github.com/user-attachments/assets/a08f80ac-7445-4b4e-a7a8-ea99c0fffaff" />  

<br/>
<br/>

프로젝트 루트 경로에서 `npx reg-suit init`  을 통해 필요한 플러그인 을 추가로 설치할 수 있다.

<img width="835" alt="스크린샷 2025-03-09 오후 5 08 38" src="https://github.com/user-attachments/assets/38a14ad5-7786-45a7-85ca-5b1b53013bd7" />  

- `reg-keygen-git-hash-plugin` , `reg-publish-s3-plugin` - 원격 환경에서 이미지를 비교하기 위한 라이브러리

  → 커밋 해시로 저장된 스냅숏 셋 및 검증 결과 리포트를 AWS S3로 전송, 토픽 브랜치 기반 커밋에서 스냅숏 셋을 추출하여 기댓값으로 사용하고 이후 커밋의 스냅숏들과 비교하여 차이점을 확인한다.

- `reg-notify-github-plugin` - 검증 결과를 github PR에다가 알려주는 플러그인

<br />

## 🟢 시각적 회귀 테스트를 활용한 적극적 리팩터링

#### 1. **반응형 디자인에 활용하기**
  
  반응형으로 디자인된 프로젝트에서 효율적으로 회귀테스트를 활용할 수 있다. 

  PC용 디자인을 먼저 만들고, 시각적 회귀 테스트 설정이 되어 있다면 이후 반응형 스타일을 적용하면서 실수를 줄일 수 있다.

#### 2. **릴리스 직전의 리팩터링에 활용하기**
  
  전역 스타일 코드의 경우 해당 스타일 코드가 미치는 영향력을 코드만으로 판단하기 어렵기 때문에 시각적 회귀 테스트를 통해 전역 코드를 리팩터링 할 수 있다.

#### 3. **스토리 커밋 습관화로 시작하는 시각적 회귀 테스트**
  
  스토리를 통해 컴포넌트를 개발하면 컴포넌트 단위로 시각적 회귀 테스트를 실시하는 것이 쉽다. 그리고 그만큼 세밀한 테스트가 가능해진다.
